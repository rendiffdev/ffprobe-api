# FFprobe API - Simplified Production Docker Build
# Focuses on core functionality with working dependencies

FROM golang:1.23-alpine AS builder

# Install build dependencies
RUN apk add --no-cache \
    git \
    ca-certificates \
    gcc \
    musl-dev \
    sqlite-dev

WORKDIR /build

# Initialize a simple Go module and handle dependencies
RUN go mod init rendiff-probe-simple && \
    go get github.com/gin-gonic/gin@latest && \
    go mod tidy

# Copy source code
COPY . .

# Create a minimal main.go for core functionality
RUN cat > /build/main.go << 'EOF'
package main

import (
    "fmt"
    "log"
    "net/http"
    "os"
    "os/exec"
    "context"
    "time"
    
    "github.com/gin-gonic/gin"
)

func main() {
    // Set Gin mode
    gin.SetMode(gin.ReleaseMode)
    
    // Create router
    r := gin.Default()
    
    // Health check endpoint
    r.GET("/health", func(c *gin.Context) {
        // Check FFprobe availability
        _, err := exec.LookPath("ffprobe")
        if err != nil {
            c.JSON(http.StatusServiceUnavailable, gin.H{
                "status": "unhealthy",
                "error": "ffprobe not found",
            })
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "status": "healthy",
            "service": "rendiff-probe",
            "version": "v1.0.0",
            "ffmpeg": "available",
        })
    })
    
    // Basic probe endpoint
    r.POST("/api/v1/probe/file", func(c *gin.Context) {
        var request struct {
            Path string `json:"path"`
        }
        
        if err := c.ShouldBindJSON(&request); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // Basic ffprobe execution
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        cmd := exec.CommandContext(ctx, "ffprobe", "-v", "quiet", "-print_format", "json", "-show_format", "-show_streams", request.Path)
        output, err := cmd.Output()
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        
        c.Header("Content-Type", "application/json")
        c.String(http.StatusOK, string(output))
    })
    
    // Version endpoint
    r.GET("/api/v1/version", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "service": "rendiff-probe",
            "version": "v1.0.0",
            "build": "docker",
        })
    })
    
    port := os.Getenv("API_PORT")
    if port == "" {
        port = "8080"
    }
    
    log.Printf("Starting FFprobe API on port %s", port)
    if err := r.Run(":" + port); err != nil {
        log.Fatal("Failed to start server:", err)
    }
}
EOF

# Build simplified application
RUN CGO_ENABLED=1 GOOS=linux go build -ldflags='-w -s' -o rendiff-probe /build/main.go

# =============================================================================
# FFmpeg Stage - Latest Static Builds
# =============================================================================
FROM alpine:3.19 AS ffmpeg

RUN apk add --no-cache curl tar xz

# Download FFmpeg for detected architecture
RUN ARCH=$(uname -m) && \
    echo "Detected architecture: $ARCH" && \
    if [ "$ARCH" = "x86_64" ]; then \
        FFMPEG_ARCH="linux64"; \
    elif [ "$ARCH" = "aarch64" ]; then \
        FFMPEG_ARCH="linuxarm64"; \
    else \
        echo "Unsupported architecture: $ARCH"; \
        exit 1; \
    fi && \
    echo "Using FFmpeg architecture: $FFMPEG_ARCH" && \
    curl -fsSL "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-${FFMPEG_ARCH}-gpl.tar.xz" \
    | tar -xJ --strip-components=1 -C /tmp/

# =============================================================================
# Production Stage
# =============================================================================
FROM alpine:3.19 AS production

# Install runtime dependencies
RUN apk add --no-cache \
    ca-certificates \
    tzdata \
    curl \
    dumb-init

# Create app user
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

WORKDIR /app

# Copy FFmpeg binaries
COPY --from=ffmpeg /tmp/bin/ffmpeg /usr/local/bin/
COPY --from=ffmpeg /tmp/bin/ffprobe /usr/local/bin/

# Make binaries executable
RUN chmod +x /usr/local/bin/ffmpeg /usr/local/bin/ffprobe

# Copy application
COPY --from=builder /build/rendiff-probe /app/

# Create directories
RUN mkdir -p /app/{data,uploads,reports,temp} && \
    chown -R appuser:appgroup /app

# Health check script
RUN echo '#!/bin/sh' > /app/healthcheck.sh && \
    echo 'curl -f http://localhost:8080/health || exit 1' >> /app/healthcheck.sh && \
    chmod +x /app/healthcheck.sh

# Expose port
EXPOSE 8080

# Environment variables
ENV API_PORT=8080 \
    GIN_MODE=release \
    PATH="/usr/local/bin:$PATH"

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD ["/app/healthcheck.sh"]

# Use dumb-init and switch to non-root user
ENTRYPOINT ["/usr/bin/dumb-init", "--"]
USER appuser:appgroup

CMD ["/app/rendiff-probe"]