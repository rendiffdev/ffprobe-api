# FFprobe API - Minimal Working Docker Image
# This is a simplified version that focuses on getting a working container

FROM alpine:3.20

LABEL maintainer="FFprobe API Team" \
      description="FFprobe API - Minimal Working Image" \
      version="1.0.0-minimal"

# Install runtime dependencies
RUN apk add --no-cache \
    ca-certificates \
    tzdata \
    bash \
    curl \
    dumb-init \
    # FFmpeg runtime libraries
    libstdc++ \
    libgcc \
    && rm -rf /var/cache/apk/*

# Download FFmpeg binaries
WORKDIR /tmp
RUN curl -L "https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-linux64-gpl.tar.xz" -o ffmpeg.tar.xz && \
    tar -xJf ffmpeg.tar.xz && \
    mv ffmpeg-master-latest-linux64-gpl/bin/ffmpeg /usr/local/bin/ && \
    mv ffmpeg-master-latest-linux64-gpl/bin/ffprobe /usr/local/bin/ && \
    chmod +x /usr/local/bin/ffmpeg /usr/local/bin/ffprobe && \
    rm -rf /tmp/*

# Create application user and directories
RUN adduser -D -u 1000 -s /bin/sh ffprobe && \
    mkdir -p /app/{uploads,temp,reports,logs} && \
    chown -R ffprobe:ffprobe /app

WORKDIR /app

# Create a simple web server that provides FFprobe functionality
RUN cat > /app/server.py << 'EOF'
#!/usr/bin/env python3
"""
Simple FFprobe API Server
Provides basic video analysis functionality using FFprobe
"""

import json
import os
import subprocess
import tempfile
import uuid
from datetime import datetime
from pathlib import Path

from flask import Flask, request, jsonify, send_file
from werkzeug.utils import secure_filename

app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100MB max file size

# Configuration
UPLOAD_FOLDER = '/app/uploads'
TEMP_FOLDER = '/app/temp'
REPORTS_FOLDER = '/app/reports'
LOGS_FOLDER = '/app/logs'

# Ensure directories exist
for folder in [UPLOAD_FOLDER, TEMP_FOLDER, REPORTS_FOLDER, LOGS_FOLDER]:
    Path(folder).mkdir(exist_ok=True)

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    try:
        # Test FFprobe is working
        result = subprocess.run(['/usr/local/bin/ffprobe', '-version'], 
                              capture_output=True, text=True, timeout=5)
        ffprobe_working = result.returncode == 0
    except:
        ffprobe_working = False
    
    return jsonify({
        'status': 'healthy' if ffprobe_working else 'unhealthy',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '1.0.0-minimal',
        'ffprobe_available': ffprobe_working
    })

@app.route('/api/v1/probe', methods=['POST'])
def probe_video():
    """Analyze video file using FFprobe"""
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    # Save uploaded file
    filename = secure_filename(file.filename)
    file_id = str(uuid.uuid4())
    temp_path = os.path.join(TEMP_FOLDER, f"{file_id}_{filename}")
    
    try:
        file.save(temp_path)
        
        # Run FFprobe analysis
        cmd = [
            '/usr/local/bin/ffprobe',
            '-v', 'quiet',
            '-print_format', 'json',
            '-show_format',
            '-show_streams',
            temp_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        
        if result.returncode != 0:
            return jsonify({
                'error': 'FFprobe analysis failed',
                'details': result.stderr
            }), 500
        
        # Parse FFprobe output
        probe_data = json.loads(result.stdout)
        
        # Clean up temp file
        os.unlink(temp_path)
        
        # Return analysis results
        return jsonify({
            'file_id': file_id,
            'filename': filename,
            'analysis': probe_data,
            'timestamp': datetime.utcnow().isoformat()
        })
        
    except subprocess.TimeoutExpired:
        if os.path.exists(temp_path):
            os.unlink(temp_path)
        return jsonify({'error': 'Analysis timeout'}), 500
    
    except Exception as e:
        if os.path.exists(temp_path):
            os.unlink(temp_path)
        return jsonify({'error': str(e)}), 500

@app.route('/api/v1/version', methods=['GET'])
def get_version():
    """Get version information"""
    return jsonify({
        'version': '1.0.0-minimal',
        'build_date': '2025-01-18',
        'description': 'FFprobe API - Minimal Working Image'
    })

if __name__ == '__main__':
    print("🚀 Starting FFprobe API Server (Minimal Version)")
    print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    print("📡 API will be available on port 8080")
    print("🔍 Health check: http://localhost:8080/health")
    print("📤 Upload endpoint: http://localhost:8080/api/v1/probe")
    print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    
    app.run(host='0.0.0.0', port=8080, debug=False)
EOF

# Install Python and Flask
RUN apk add --no-cache python3 py3-flask py3-werkzeug

# Make server executable
RUN chmod +x /app/server.py && chown ffprobe:ffprobe /app/server.py

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Switch to non-root user
USER ffprobe

# Expose port
EXPOSE 8080

# Volume mount points
VOLUME ["/app/uploads", "/app/reports", "/app/logs"]

# Use dumb-init for proper signal handling
ENTRYPOINT ["/usr/bin/dumb-init", "--"]

# Start the server
CMD ["python3", "/app/server.py"]