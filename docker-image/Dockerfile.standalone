# FFprobe API - Standalone Production Docker Image
# Zero-dependency deployment - Just run and use!
# Everything pre-configured for production use

# Stage 1: Download FFmpeg binaries from BtbN
FROM alpine:3.20 AS ffmpeg-downloader

RUN apk add --no-cache curl tar xz jq ca-certificates

WORKDIR /tmp

# Download the latest stable FFmpeg build from BtbN
RUN curl -s https://api.github.com/repos/BtbN/FFmpeg-Builds/releases/latest | \
    jq -r '.assets[] | select(.name | contains("linux64-gpl.tar.xz") and contains("master")) | .browser_download_url' | \
    head -1 | xargs curl -L -o ffmpeg.tar.xz && \
    tar -xJf ffmpeg.tar.xz && \
    mv ffmpeg-*/bin/ffmpeg /usr/local/bin/ && \
    mv ffmpeg-*/bin/ffprobe /usr/local/bin/ && \
    chmod +x /usr/local/bin/ffmpeg /usr/local/bin/ffprobe

# Download VMAF models for quality analysis
RUN mkdir -p /usr/local/share/vmaf && \
    cd /usr/local/share/vmaf && \
    curl -sLO https://github.com/Netflix/vmaf/raw/master/model/vmaf_v0.6.1.json && \
    curl -sLO https://github.com/Netflix/vmaf/raw/master/model/vmaf_v0.6.1neg.json && \
    curl -sLO https://github.com/Netflix/vmaf/raw/master/model/vmaf_4k_v0.6.1.json && \
    curl -sLO https://github.com/Netflix/vmaf/raw/master/model/vmaf_b_v0.6.3.json

# Stage 2: Download AI models
FROM ollama/ollama:latest AS ai-models

# Download AI models for offline use
RUN ollama serve & \
    sleep 10 && \
    ollama pull gemma2:2b && \
    ollama pull phi3:mini && \
    pkill ollama

# Stage 3: Build Go application with embedded database
FROM golang:1.22-alpine AS builder

RUN apk add --no-cache git build-base ca-certificates sqlite-dev

WORKDIR /build

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build with all optimizations and SQLite embedded
RUN CGO_ENABLED=1 GOOS=linux GOARCH=amd64 \
    go build -ldflags="-w -s -X main.version=standalone -X main.buildTime=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
    -tags="sqlite_foreign_keys sqlite_stat4" \
    -o ffprobe-api cmd/ffprobe-api/main.go

# Stage 4: Create standalone production image
FROM alpine:3.20

LABEL maintainer="FFprobe API Team" \
      description="AI-Powered Video Analysis API - Production Ready" \
      version="1.0.0" \
      org.opencontainers.image.title="FFprobe API Standalone" \
      org.opencontainers.image.description="Zero-dependency production deployment" \
      org.opencontainers.image.vendor="FFprobe API" \
      org.opencontainers.image.licenses="MIT"

# Install runtime dependencies and create optimized system
RUN apk add --no-cache \
    ca-certificates \
    tzdata \
    bash \
    curl \
    sqlite \
    # FFmpeg runtime libraries
    libstdc++ \
    libgcc \
    libgomp \
    # Video processing
    mesa-gl \
    mesa-glapi \
    # Audio processing
    alsa-lib \
    # Subtitle processing
    fontconfig \
    ttf-liberation \
    # Network protocols
    librtmp \
    # Image processing
    libjpeg-turbo \
    libpng \
    libwebp \
    # Security
    dumb-init \
    && rm -rf /var/cache/apk/*

# Create production user and directories
RUN adduser -D -u 1000 -s /bin/sh ffprobe && \
    mkdir -p /app/{data,uploads,temp,cache,reports,backup,logs,db,models} && \
    chown -R ffprobe:ffprobe /app

WORKDIR /app

# Copy FFmpeg binaries from downloader stage
COPY --from=ffmpeg-downloader /usr/local/bin/ffmpeg /usr/local/bin/ffmpeg
COPY --from=ffmpeg-downloader /usr/local/bin/ffprobe /usr/local/bin/ffprobe
COPY --from=ffmpeg-downloader /usr/local/share/vmaf /usr/local/share/vmaf

# Copy AI models for offline use
COPY --from=ai-models /root/.ollama /app/models/.ollama

# Copy Go application from builder
COPY --from=builder /build/ffprobe-api /app/ffprobe-api

# Copy migrations (SQLite versions for standalone)
COPY --chown=ffprobe:ffprobe migrations/*sqlite*.sql /app/migrations/

# Create production configuration files
RUN cat > /app/production.env << 'EOF'
# FFprobe API - Production Configuration
# Auto-generated for standalone deployment

# === CORE SETTINGS ===
GO_ENV=production
GIN_MODE=release
API_PORT=8080
HOST=0.0.0.0

# === EMBEDDED DATABASE (SQLite) ===
DB_TYPE=sqlite
DB_PATH=/app/db/ffprobe.db

# === CACHE (Embedded Valkey-compatible) ===
CACHE_TYPE=file
CACHE_DIR=/app/cache

# === AI/LLM (Embedded Models) ===
ENABLE_LOCAL_LLM=true
OLLAMA_EMBEDDED=true
OLLAMA_MODELS_PATH=/app/models/.ollama
OLLAMA_MODEL=gemma2:2b
OLLAMA_FALLBACK_MODEL=phi3:mini

# === STORAGE ===
UPLOAD_DIR=/app/uploads
TEMP_DIR=/app/temp
REPORTS_DIR=/app/reports
BACKUP_DIR=/app/backup
LOGS_DIR=/app/logs
MAX_FILE_SIZE=10737418240

# === SECURITY (Production) ===
ENABLE_AUTH=false
ENABLE_RATE_LIMIT=true
RATE_LIMIT_PER_MINUTE=100
RATE_LIMIT_PER_HOUR=5000
CORS_ENABLED=true
CORS_ORIGINS=*

# === PERFORMANCE ===
WORKER_POOL_SIZE=8
PROCESSING_TIMEOUT=600
MAX_CONCURRENT_UPLOADS=10
CLEANUP_INTERVAL=3600

# === LOGGING ===
LOG_LEVEL=info
LOG_FORMAT=json
LOG_FILE=/app/logs/api.log
LOG_MAX_SIZE=100
LOG_MAX_BACKUPS=5
LOG_MAX_AGE=30

# === HEALTH & MONITORING ===
HEALTH_CHECK_INTERVAL=30
METRICS_ENABLED=true
METRICS_PORT=9090

# === FFMPEG SETTINGS ===
FFMPEG_PATH=/usr/local/bin/ffmpeg
FFPROBE_PATH=/usr/local/bin/ffprobe
VMAF_MODEL_PATH=/usr/local/share/vmaf
FFMPEG_THREAD_COUNT=0
FFMPEG_PRESET=medium

# === ADVANCED QC FEATURES ===
ENABLE_ADVANCED_QC=true
ENABLE_TIMECODE_ANALYSIS=true
ENABLE_MXF_VALIDATION=true
ENABLE_PSE_ANALYSIS=true
ENABLE_DEAD_PIXEL_DETECTION=true
ENABLE_AUDIO_ANALYSIS=true
ENABLE_SUBTITLE_ANALYSIS=true

# === AUTO-CLEANUP ===
AUTO_CLEANUP_ENABLED=true
CLEANUP_UPLOADS_AFTER_HOURS=24
CLEANUP_REPORTS_AFTER_DAYS=7
CLEANUP_TEMP_AFTER_HOURS=1
CLEANUP_LOGS_AFTER_DAYS=30
EOF

# Create comprehensive startup script
RUN cat > /app/startup.sh << 'EOF'
#!/bin/bash
set -e

echo "🚀 Starting FFprobe API Standalone Production Server..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Initialize database and directories
echo "📂 Initializing directories..."
mkdir -p /app/{db,uploads,temp,cache,reports,backup,logs}
chmod 755 /app/{db,uploads,temp,cache,reports,backup,logs}

# Initialize SQLite database
echo "🗄️  Initializing embedded database..."
if [ ! -f "/app/db/ffprobe.db" ]; then
    sqlite3 /app/db/ffprobe.db "SELECT 1;" > /dev/null
    echo "✅ Database initialized"
else
    echo "✅ Database already exists"
fi

# Initialize embedded AI if available
echo "🧠 Checking AI models..."
if [ -d "/app/models/.ollama" ]; then
    export OLLAMA_MODELS=/app/models/.ollama
    echo "✅ Embedded AI models ready"
else
    echo "⚠️  AI models not found - AI features disabled"
    export ENABLE_LOCAL_LLM=false
fi

# Set up log rotation
echo "📝 Setting up logging..."
touch /app/logs/api.log
chmod 644 /app/logs/api.log

# Run database migrations
echo "🔄 Running database migrations..."
if /app/ffprobe-api migrate --config /app/production.env; then
    echo "✅ Database migrations completed"
else
    echo "⚠️  Migration failed, continuing anyway..."
fi

# Display startup information
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🎯 FFprobe API Production Server Ready!"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📡 API Endpoint: http://localhost:8080"
echo "🔍 Health Check: http://localhost:8080/health"
echo "📊 Metrics: http://localhost:8080/metrics"
echo "📖 API Docs: http://localhost:8080/docs"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🧠 AI Analysis: $([ "$ENABLE_LOCAL_LLM" = "true" ] && echo "✅ Enabled" || echo "❌ Disabled")"
echo "🗄️  Database: SQLite (embedded)"
echo "💾 Cache: File-based"
echo "📁 Upload Limit: 10GB"
echo "⚡ Workers: 8"
echo "🔒 Authentication: $([ "$ENABLE_AUTH" = "true" ] && echo "✅ Enabled" || echo "❌ Disabled")"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Start the application with production configuration
echo "🚀 Starting FFprobe API server..."
exec /app/ffprobe-api --config /app/production.env "$@"
EOF

# Create health check script
RUN cat > /app/health-check.sh << 'EOF'
#!/bin/bash
# Comprehensive health check for production deployment

# Check API endpoint
if ! curl -f -s http://localhost:8080/health > /dev/null; then
    echo "❌ API health check failed"
    exit 1
fi

# Check database
if [ -f "/app/db/ffprobe.db" ]; then
    if ! sqlite3 /app/db/ffprobe.db "SELECT 1;" > /dev/null 2>&1; then
        echo "❌ Database health check failed"
        exit 1
    fi
fi

# Check FFmpeg
if ! /usr/local/bin/ffmpeg -version > /dev/null 2>&1; then
    echo "❌ FFmpeg health check failed"
    exit 1
fi

# Check disk space
DISK_USAGE=$(df /app | tail -1 | awk '{print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -gt 90 ]; then
    echo "⚠️  Disk usage high: ${DISK_USAGE}%"
fi

echo "✅ All health checks passed"
exit 0
EOF

# Create production maintenance script
RUN cat > /app/maintenance.sh << 'EOF'
#!/bin/bash
# Production maintenance tasks

case "${1:-help}" in
    backup)
        echo "🔄 Creating backup..."
        DATE=$(date +%Y%m%d_%H%M%S)
        mkdir -p /app/backup
        
        # Backup database
        if [ -f "/app/db/ffprobe.db" ]; then
            cp /app/db/ffprobe.db /app/backup/database_$DATE.db
            echo "✅ Database backed up"
        fi
        
        # Backup uploads (if any)
        if [ "$(ls -A /app/uploads 2>/dev/null)" ]; then
            tar -czf /app/backup/uploads_$DATE.tar.gz -C /app/uploads .
            echo "✅ Uploads backed up"
        fi
        
        echo "✅ Backup completed: $DATE"
        ;;
        
    cleanup)
        echo "🧹 Running cleanup..."
        
        # Clean temp files older than 1 hour
        find /app/temp -type f -mmin +60 -delete 2>/dev/null || true
        
        # Clean old logs (keep last 30 days)
        find /app/logs -name "*.log.*" -mtime +30 -delete 2>/dev/null || true
        
        # Clean old reports (keep last 7 days)
        find /app/reports -type f -mtime +7 -delete 2>/dev/null || true
        
        # Clean old backups (keep last 5)
        ls -t /app/backup/database_*.db 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
        ls -t /app/backup/uploads_*.tar.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
        
        echo "✅ Cleanup completed"
        ;;
        
    status)
        echo "📊 FFprobe API Status"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # API Status
        if curl -f -s http://localhost:8080/health > /dev/null; then
            echo "✅ API: Running"
        else
            echo "❌ API: Not responding"
        fi
        
        # Database Status
        if [ -f "/app/db/ffprobe.db" ] && sqlite3 /app/db/ffprobe.db "SELECT 1;" > /dev/null 2>&1; then
            echo "✅ Database: Connected"
            DB_SIZE=$(du -h /app/db/ffprobe.db | cut -f1)
            echo "   Size: $DB_SIZE"
        else
            echo "❌ Database: Error"
        fi
        
        # Disk Usage
        echo "💾 Disk Usage:"
        df -h /app | tail -1 | awk '{print "   " $4 " available (" $5 " used)"}'
        
        # Memory Usage
        echo "🧠 Memory Usage:"
        free -h | grep Mem | awk '{print "   " $3 "/" $2 " used (" int($3/$2*100) "%)"}'
        
        # Uptime
        echo "⏱️  Uptime: $(uptime -p)"
        ;;
        
    *)
        echo "FFprobe API Maintenance Tool"
        echo ""
        echo "Usage: $0 {backup|cleanup|status}"
        echo ""
        echo "Commands:"
        echo "  backup  - Create backup of database and uploads"
        echo "  cleanup - Clean temporary files and old data"
        echo "  status  - Show system status"
        ;;
esac
EOF

# Make scripts executable and set ownership
RUN chmod +x /app/startup.sh /app/health-check.sh /app/maintenance.sh /app/ffprobe-api && \
    chown -R ffprobe:ffprobe /app

# Create version info
RUN cat > /app/VERSION << 'EOF'
FFprobe API Standalone Production Image
Version: 1.0.0
Build Type: Docker Hub Production
FFmpeg: Latest Stable (BtbN)
AI Models: Embedded (Gemma2:2b, Phi3:mini)
Database: SQLite (embedded)
Features: All QC + AI Analysis
Build Date: BUILD_DATE_PLACEHOLDER
EOF

# Set production environment variables
ENV PRODUCTION=true \
    GO_ENV=production \
    GIN_MODE=release \
    API_PORT=8080 \
    HOST=0.0.0.0 \
    \
    DB_TYPE=sqlite \
    DB_PATH=/app/db/ffprobe.db \
    \
    CACHE_TYPE=file \
    CACHE_DIR=/app/cache \
    \
    ENABLE_LOCAL_LLM=true \
    OLLAMA_EMBEDDED=true \
    OLLAMA_MODELS_PATH=/app/models/.ollama \
    \
    FFMPEG_PATH=/usr/local/bin/ffmpeg \
    FFPROBE_PATH=/usr/local/bin/ffprobe \
    VMAF_MODEL_PATH=/usr/local/share/vmaf \
    \
    UPLOAD_DIR=/app/uploads \
    TEMP_DIR=/app/temp \
    CACHE_DIR=/app/cache \
    REPORTS_DIR=/app/reports \
    BACKUP_DIR=/app/backup \
    LOGS_DIR=/app/logs \
    \
    ENABLE_AUTH=false \
    ENABLE_RATE_LIMIT=true \
    ENABLE_ADVANCED_QC=true \
    \
    WORKER_POOL_SIZE=8 \
    PROCESSING_TIMEOUT=600 \
    MAX_FILE_SIZE=10737418240 \
    \
    AUTO_CLEANUP_ENABLED=true \
    LOG_LEVEL=info

# Health check that works in production
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD /app/health-check.sh

# Switch to non-root user
USER ffprobe

# Expose API port
EXPOSE 8080

# Volume mount points for persistent data
VOLUME ["/app/uploads", "/app/reports", "/app/db", "/app/backup", "/app/logs"]

# Use dumb-init for proper signal handling in production
ENTRYPOINT ["/usr/bin/dumb-init", "--"]

# Start with production script
CMD ["/app/startup.sh"]